Microcode is a layer of hardware level instructions that implement higher level machine code instructions or internal state machine sequencing in many digital processing elements  Microcode is used in general central processing units  in more specialized processors such as microcontrollers  digital signal processors  channel controllers  disk controllers  network interface controllers  network processors  graphics processing units  and in other hardware   Microcode typically resides in special high speed memory and translates machine instructions  state machine data or other input into sequences of detailed circuit level operations  It separates the machine instructions from the underlying electronics so that instructions can be designed and altered more freely  It also facilitates the building of complex multi step instructions  while reducing the complexity of computer circuits  Writing microcode is often called microprogramming and the microcode in a particular processor implementation is sometimes called a microprogram   More extensive microcoding allows small and simple microarchitectures to emulate more powerful architectures with wider word length  more execution units and so on  which is a relatively simple way to achieve software compatibility between different products in a processor family   Some hardware vendors  especially IBM  use the term  microcode  as a synonym for  firmware   That way  all code in a device is termed  microcode  regardless of it being microcode or machine code  for example  hard disk drives are said to have their microcode updated  though they typically contain both microcode and firmware   1  Overview  When compared to normal application programs  the elements composing a microprogram exist on a lower conceptual level  To avoid confusion  each microprogram related element is differentiated by the  micro  prefix  microinstruction  microassembler  microprogrammer  microarchitecture  etc   Engineers normally write the microcode during the design phase of a processor  storing it in a ROM  read only memory  or PLA  programmable logic array  structure  or in a combination of both  However  machines also exist that have some  or all  microcode stored in SRAM or flash memory  This is traditionally denoted a  writeable control store  in the context of computers  which can be either read only or read write memory  In the latter case  the CPU initialization process loads microcode into the control store from another storage medium  with the possibility of altering the microcode to correct bugs in the instruction set  or to implement new machine instructions   Complex digital processors may also employ more than one  possibly microcode based  control unit in order to delegate sub tasks that must be performed  more or less  asynchronously in parallel  A high level programmer  or even an assembly programmer  does not normally see or change microcode  Unlike machine code  which often retains some compatibility among different processors in a family  microcode only runs on the exact electronic circuitry for which it is designed  as it constitutes an inherent part of the particular processor design itself   Microprograms consist of series of microinstructions  which control the CPU at a very fundamental level of hardware circuitry  For example  a single typical microinstruction might specify the following operations   Connect Register 1 to the  A  side of the ALU  Connect Register 7 to the  B  side of the ALU  Set the ALU to perform two s complement addition  Set the ALU s carry input to zero  Store the result value in Register 8  Update the  condition codes  with the ALU status flags   Negative    Zero    Overflow   and  Carry    Microjump to MicroPC nnn for the next microinstruction To simultaneously control all processor s features in one cycle  the microinstruction is often wider than 50 bits  e g   128 bits on a 360 85 with an emulator feature  Microprograms are carefully designed and optimized for the fastest possible execution  as a slow microprogram would result in a slow machine instruction and degraded performance for related application programs that use such instructions   2  The reason for microprogramming  Microcode was originally developed as a simpler method of developing the control logic for a computer  Initially  CPU instruction sets were  hardwired   Each step needed to fetch  decode  and execute the machine instructions  including any operand address calculations  reads  and writes  was controlled directly by combinational logic and rather minimal sequential state machine circuitry  While very efficient  the need for powerful instruction sets with multi step addressing and complex operations  see below  made such hard wired processors difficult to design and debug  highly encoded and varied length instructions can contribute to this as well  especially when very irregular encodings are used   Microcode simplified the job by allowing much of the processor s behaviour and programming model to be defined via microprogram routines rather than by dedicated circuitry  Even late in the design process  microcode could easily be changed  whereas hard wired CPU designs were very cumbersome to change  Thus  this greatly facilitated CPU design   From the 1940s to the late 1970s  much programming was done in assembly language  higher level instructions meant greater programmer productivity  so an important advantage of microcode was the relative ease by which powerful machine instructions could be defined  During the 1970s  CPU speeds grew more quickly than memory speeds and numerous techniques such as memory block transfer  memory pre fetch and multi level caches were used to alleviate this  High level machine instructions  made possible by microcode  helped further  as fewer more complex machine instructions require less memory bandwidth  For example  an operation on a character string could be done as a single machine instruction  thus avoiding multiple instruction fetches   Architectures with instruction sets implemented by complex microprograms included the IBM System 360 and Digital Equipment Corporation VAX  The approach of increasingly complex microcode implemented instruction sets was later called CISC  An alternate approach  used in many microprocessors  is to use PLAs or ROMs  instead of combinational logic  mainly for instruction decoding  and let a simple state machine  without much  or any  microcode  do most of the sequencing   Microprogramming is still used in modern CPU designs  In some cases  after the microcode is debugged in simulation  logic functions are substituted for the control store  Logic functions are often faster and less expensive than the equivalent microprogram memory   2 1  Benefits  A processor s microprograms operate on a more primitive  totally different and much more hardware oriented architecture than the assembly instructions visible to normal programmers  In coordination with the hardware  the microcode implements the programmer visible architecture  The underlying hardware need not have a fixed relationship to the visible architecture  This makes it easier to implement a given instruction set architecture on a wide variety of underlying hardware micro architectures   The IBM System 360 had a 32 bit architecture with 16 general purpose registers  but most of the System 360 implementations actually use hardware that implemented a much simpler underlying microarchitecture  for example  the System 360 Model 30 had 8 bit data paths to the arithmetic logic unit  ALU  and main memory and implemented the general purpose registers in a special unit of higher speed core memory  and the System 360 Model 40 had 8 bit data paths to the ALU and 16 bit data paths to main memory and also implemented the general purpose registers in a special unit of higher speed core memory  The Model 50 and Model 65 had full 32 bit data paths  the Model 50 implemented the general purpose registers in a special unit of higher speed core memory and the Model 65 implemented the general purpose registers in faster transistor circuits  In this way  microprogramming enabled IBM to design many System 360 models with substantially different hardware and spanning a wide range of cost and performance  while making them all architecturally compatible  This dramatically reduced the number of unique system software programs that had to be written for each model   A similar approach was used by Digital Equipment Corporation in their VAX family of computers  Initially a 32 bit TTL processor in conjunction with supporting microcode implemented the programmer visible architecture  Later VAX versions used different microarchitectures  yet the programmer visible architecture did not change   Microprogramming also reduced the cost of field changes to correct defects  bugs  in the processor  a bug could often be fixed by replacing a portion of the microprogram rather than by changes being made to hardware logic and wiring   3  History  In 1947  the design of the MIT Whirlwind introduced the concept of a control store as a way to simplify computer design and move beyond ad hoc methods  The control store was a diode matrix  a two dimensional lattice  where one dimension accepted  control time pulses  from the CPU s internal clock  and the other connected to control signals on gates and other circuits  A  pulse distributor  would take the pulses generated by the CPU clock and break them up into eight separate time pulses  each of which would activate a different row of the lattice  When the row was activated  it would activate the control signals connected to it   Described another way  the signals transmitted by the control store are being played much like a player piano roll  That is  they are controlled by a sequence of very wide words constructed of bits  and they are  played  sequentially  In a control store  however  the  song  is short and repeated continuously   In 1951 Maurice Wilkes enhanced this concept by adding conditional execution  a concept akin to a conditional in computer software  His initial implementation consisted of a pair of matrices  the first one generated signals in the manner of the Whirlwind control store  while the second matrix selected which row of signals  the microprogram instruction word  as it were  to invoke on the next cycle  Conditionals were implemented by providing a way that a single line in the control store could choose from alternatives in the second matrix  This made the control signals conditional on the detected internal signal  Wilkes coined the term microprogramming to describe this feature and distinguish it from a simple control store   4  Examples of microprogrammed systems  In common with many other complex mechanical devices  Charles Babbage s analytical engine used banks of cams to control each operation  That is  it had a read only control store  As such it deserves to be recognised as the first microprogrammed computer to be designed  even if it has not yet been realised in hardware   The EMIDEC 1100 reputedly used a hard wired control store consisting of wires threaded through ferrite cores  known as  the laces    Most models of the IBM System 360 series were microprogrammed   The NCR 315 was microprogrammed with hand wired ferrite cores  a ROM  pulsed by a sequencer with conditional execution  Wires routed through the cores were enabled for various data and logic elements in the processor   The Digital Equipment Corporation PDP 11 processors  with the exception of the PDP 11 20  were microprogrammed   Most Data General Eclipse minicomputers were microprogrammed  The task of writing microcode for the Eclipse MV 8000 was detailed in the Pulitzer Prize winning book The Soul of a New Machine   Many systems from Burroughs were microprogrammed   Microdata produced computers in which the microcode was accessible to the user  this allowed the creation of custom assembler level instructions  Microdata s Reality operating system design made extensive use of this capability   The Nintendo 64 s Reality Co Processor  which serves as the console s graphics processing unit and audio processor  utilized microcode  it is possible to implement new effects or tweak the processor to achieve the desired output  Some well known examples of custom microcode include Factor 5 s Nintendo 64 ports of the Indiana Jones and the Infernal Machine  Star Wars  Rogue Squadron and Star Wars  Battle for Naboo   The VU0 and VU1 vector units in the Sony PlayStation 2 are microprogrammable  in fact  VU1 was only accessible via microcode for the first several generations of the SDK   5  Implementation  Each microinstruction in a microprogram provides the bits that control the functional elements that internally compose a CPU  The advantage over a hard wired CPU is that internal CPU control becomes a specialized form of a computer program  Microcode thus transforms a complex electronic design challenge  the control of a CPU  into a less complex programming challenge   To take advantage of this  computers were divided into several parts   A microsequencer picked the next word of the control store  A sequencer is mostly a counter  but usually also has some way to jump to a different part of the control store depending on some data  usually data from the instruction register and always some part of the control store  The simplest sequencer is just a register loaded from a few bits of the control store   A register set is a fast memory containing the data of the central processing unit  It may include the program counter  stack pointer  and other numbers that are not easily accessible to the application programmer  Often the register set is a triple ported register file  that is  two registers can be read  and a third written at the same time   An arithmetic and logic unit performs calculations  usually addition  logical negation  a right shift  and logical AND  It often performs other functions  as well   There may also be a memory address register and a memory data register  used to access the main computer storage   Together  these elements form an  execution unit   Most modern CPUs have several execution units  Even simple computers usually have one unit to read and write memory  and another to execute user code   These elements could often be brought together as a single chip  This chip came in a fixed width that would form a  slice  through the execution unit  These were known as  bit slice  chips  The AMD Am2900 family is one of the best known examples of bit slice elements   The parts of the execution units and the execution units themselves are interconnected by a bundle of wires called a bus   Programmers develop microprograms  using basic software tools  A microassembler allows a programmer to define the table of bits symbolically  A simulator program executes the bits in the same way as the electronics  hopefully   and allows much more freedom to debug the microprogram   After the microprogram is finalized  and extensively tested  it is sometimes used as the input to a computer program that constructs logic to produce the same data  This program is similar to those used to optimize a programmable logic array  No known computer program can produce optimal logic  but even pretty good logic can vastly reduce the number of transistors from the number required for a ROM control store  This reduces the cost of producing  and the electricity consumed by  a CPU   Microcode can be characterized as horizontal or vertical  This refers primarily to whether each microinstruction directly controls CPU elements  horizontal microcode   or requires subsequent decoding by combinatorial logic before doing so  vertical microcode   Consequently each horizontal microinstruction is wider  contains more bits  and occupies more storage space than a vertical microinstruction   5 1  Horizontal microcode  Horizontal microcode is typically contained in a fairly wide control store  it is not uncommon for each word to be 108 bits or more  On each tick of a sequencer clock a microcode word is read  decoded  and used to control the functional elements that make up the CPU   In a typical implementation a horizontal microprogram word comprises fairly tightly defined groups of bits  For example  one simple arrangement might be   For this type of micromachine to implement a JUMP instruction with the address following the opcode  the microcode might require two clock ticks  The engineer designing it would write microassembler source code looking something like this   For each tick it is common to find that only some portions of the CPU are used  with the remaining groups of bits in the microinstruction being no ops  With careful design of hardware and microcode  this property can be exploited to parallelise operations that use different areas of the CPU  for example  in the case above  the ALU is not required during the first tick  so it could potentially be used to complete an earlier arithmetic instruction   5 2  Vertical microcode  In vertical microcode  each microinstruction is encoded—that is  the bit fields may pass through intermediate combinatory logic that in turn generates the actual control signals for internal CPU elements  ALU  registers  etc    In contrast  with horizontal microcode the bit fields themselves directly produce the control signals  Consequently vertical microcode requires smaller instruction lengths and less storage  but requires more time to decode  resulting in a slower CPU clock   Some vertical microcode is just the assembly language of a simple conventional computer that is emulating a more complex computer  Some processors  such as DEC Alpha processors and the CMOS microprocessors on later IBM System 390 mainframes and z Architecture mainframes  have PALcode  the term used on Alpha processors  or millicode  the term used on IBM mainframe microprocessors   This is a form of machine code  with access to special registers and other hardware resources not available to regular machine code  used to implement some instructions and other functions  such as page table walks on Alpha processors   Another form of vertical microcode has two fields   The  field select  selects which part of the CPU will be controlled by this word of the control store  The  field value  actually controls that part of the CPU  With this type of microcode  a designer explicitly chooses to make a slower CPU to save money by reducing the unused bits in the control store  however  the reduced complexity may increase the CPU s clock frequency  which lessens the effect of an increased number of cycles per instruction   As transistors became cheaper  horizontal microcode came to dominate the design of CPUs using microcode  with vertical microcode being used less often   6  Writable control stores  A few computers were built using  writable microcode   In this design  rather than storing the microcode in ROM or hard wired logic  the microcode was stored in a RAM called a Writable Control Store or WCS  Such a computer is sometimes called a Writable Instruction Set Computer or WISC   Many experimental prototype computers used writable control stores  and there were also commercial machines that used writable microcode  such as the Burroughs Small Systems  early Xerox workstations  the DEC VAX 8800   Nautilus   family  the Symbolics L  and G machines  a number of IBM System 360 and System 370 implementations  some DEC PDP 10 machines  and the Data General Eclipse MV 8000   Many more machines offered user programmable writable control stores as an option  including the HP 2100  DEC PDP 11 60 and Varian Data Machines V 70 series minicomputers   The IBM System 370 included a facility called Initial Microprogram Load  IML or IMPL  that could be invoked from the console  as part of Power On Reset  POR  or from another processor in a tightly coupled multiprocessor complex   Some commercial machines  for example IBM 360 85  had both a Read only storage and a Writable Control Store for microcode   WCS offered several advantages including the ease of patching the microprogram and  for certain hardware generations  faster access than ROMs could provide  User programmable WCS allowed the user to optimize the machine for specific purposes   Several Intel CPUs in the x86 architecture family have writable microcode  This has allowed bugs in the Intel Core 2 microcode and Intel Xeon microcode to be fixed in software  rather than requiring the entire chip to be replaced   7  Microcode versus VLIW and RISC  The design trend toward heavily microcoded processors with complex instructions began in the early 1960s and continued until roughly the mid 1980s  At that point the RISC design philosophy started becoming more prominent   A CPU that uses microcode generally takes several clock cycles to execute a single instruction  one clock cycle for each step in the microprogram for that instruction  Some CISC processors include instructions that can take a very long time to execute  Such variations interfere with both interrupt latency and  what is far more important in modern systems  pipelining   When designing a new processor  a hardwired control RISC has the following advantages over microcoded CISC   Programming has largely moved away from assembly level  so it s no longer worthwhile to provide complex instructions for productivity reasons   Simpler instruction sets allow direct execution by hardware  avoiding the performance penalty of microcoded execution   Analysis shows complex instructions are rarely used  hence the machine resources devoted to them are largely wasted   The machine resources devoted to rarely used complex instructions are better used for expediting performance of simpler  commonly used instructions   Complex microcoded instructions may require many clock cycles that vary  and are difficult to pipeline for increased performance  It should be mentioned that there are counterpoints as well   The complex instructions in heavily microcoded implementations may not take much extra machine resources  except for microcode space  For instance  the same ALU is often used to calculate an effective address as well as computing the result from the actual operands  e g  the original Z80  8086  and others    The simpler non RISC instructions  i e  involving direct memory operands  are frequently used by modern compilers  Even immediate to stack  i e  memory result  arithmetic operations are commonly employed  Although such memory operations  often with varying length encodings  are more difficult to pipeline  it is still fully feasible to do so   clearly exemplified by the i486  AMD K5  Cyrix 6x86  Motorola 68040  etc   Non RISC instructions inherently perform more work per instruction  on average   and are also normally highly encoded  so they enable smaller overall size of the same program  and thus better use of limited cache memories   Modern CISC RISC implementations  e g  x86 designs  decode instructions into dynamically buffered micro operations with instruction encodings similar to traditional fixed microcode  Ordinary static microcode is used as hardware assistance for complex multistep operations such as auto repeating instructions and for transcendental functions in the floating point unit  it is also used for special purpose instructions  such as CPUID  and internal control and configuration purposes   The simpler instructions in CISC architectures are also directly executed in hardware in modern implementations  Many RISC and VLIW processors are designed to execute every instruction  as long as it is in the cache  in a single cycle  This is very similar to the way CPUs with microcode execute one microinstruction per cycle  VLIW processors have instructions that behave similarly to very wide horizontal microcode  although typically without such fine grained control over the hardware as provided by microcode  RISC instructions are sometimes similar to the narrow vertical microcode   Microcoding remains popular in application specific processors such as network processors   8  See also  Address generation unit  AGU   CPU design  Finite state machine  FSM   Firmware  Floating point unit  FPU   Instruction pipeline  Superscalar  9  References  10  Further reading  Tucker  S  G   IBM Systems Journal  Volume 6  Number 4  pp  222–241  1967   11  External links   fixes the issues when running 32 bit virtual machines in PAE mode 